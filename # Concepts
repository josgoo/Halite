# Concepts

### (Target - Moving) Amortized Value Logic Pipeline
Similar to other teams, our logic pipeline first had every ship choose a target square on the map it wanted to reach and then assign each ship a direction to take to reach that target. To compare the value between different targets and moves, our AI ecostructure depended on an amortized value for every action. 
This value always took the form

<div align="center"> $\frac{Total \ Value \ of \ Target}{Total \ Turns \ Needed} * (Probability\ of \ Success)$ </div>

## Dominance Map
To determine the probability of success for various targets we needed to have some metric of board dominance. To do this, we designated our dominance of a square to be the probability that no enemy ship would enter the square for 2 turns given all ships move completely randomly. 

We additionally reran that process for each friendly ship to determine specific dominance maps counting only enemy ships with less cargo. The general dominance map was used for mining as any enemy ship could mine a square and steal expected halite whereas the specific dominance map was used for collision avoidance as only lighter ships could destroy out ships. 

## Assigning Ship Type
Throughout the game, we assigned ships assigned to a type. The types consisted of mining ships or attacking ships. At the end of every turn, ships re-evaluated whether they would have been better off as a mining ship or an attacking ship and chose which type they would prefer to be be for the next turn. 

Because the value of a ship mining or attacking depended on the actions of other friendly ships, the perceived value of a ship acting as the other type assumed it was the last to act and last to choose its target. This included other ships that already decided to switch.

Switching type assignment required the amortized turn value of the ship acting as the other type to be significantly higher than the current type. We implemented this buffer between the ship type values so ships would not continuously switch back and forth between types and targets.

## Mining
For each mining ship, our bot compiles a list of amortized values for each spot on the map it could mine. Our amortized value specifically solved the following maximization problem 

<div align="center"> $\max_{t} \ $<font size="+2">$ \frac{(1 \ - \ 0.75^{t}) \ * \ Halite}{dist \ + \ t}$</font>$*\ (Probability\ of \ Success)$ </div>

where H was the current halite on each block, t was the amount of time we spent mining, dist was our ship's distance to the mining location. We chose not to include any parameter for returning to base at all and instead handle that separately. The less ships returned, the less the distance from our base factored into the mining amortized value.

$\textbf{SAM MINING}$

Once our ships all had their target amortized lists, we assigned the specific target to each ship using loss. That is, we ordered ship to mining target asignment by how much lower the total amortized value would be if each ship wasn't assigned its best target. For each ship, this was simply

<div align="center">$ ship\_amortized\_list[0] - ship\_amortized\_list[1]$ </div>

Then, as we assigned targets to each mining ship, we removed assigned targets from the amortized lists and updated each ship's loss. The idea behind doing this was to attempt to maximize the total amortized value among all of our ships while still using a greedy algorithm. 

Additionally, we allowed ships to look slightly beyond their best target right now. In an attempt to better coordinate our swarm of mining ships, once a ship was assigned to a target we reran the function to compute the mining amortized value list; this time from the first target. This effectively gave us where the ship would want to travel next, not accounting for opponent movements. We then discounted other ships amortized values traveling to the second target by some $\beta$ to somewhat account for the fact that this specific ship will want to go there.

## Attacking
For each attacking ship, our bot, similar to mining ships, compiles a list of amortized values for each spot on the map it could attack. Our attacking amortized value for each square was

<div align="center"> <font size="+2"> $\sum_{e\ \in enemy\ ships} \frac{(Probabiliy\ of\ Capture)_e\ *\ (Probability\ Actualized)_e\ *\ (\ Baseline\ Ship\ Val\ +\ min(500,\ cargo_e)\ )}{(Num\ Attacking\ Ships\ on\ Target)_e\ *\ (dist\ +\ (Expected\ Capture\ Time)_e\ )}  $ </font> </div>

Here, we looked at every square within a 2 move radius from an enemy ship. Our estimated probability the ship moved to that square was (Probability Actualized). From that square, we once more predicted the probability the opponent ship would move from there in each direction. Those surrounding squares were the squares we targeted and gave a (Probability of Capture) to. 

Once our ships all had their target amortized lists, again we assigned the specific target to each ship using loss.

## Assigning Actions to Ships
To assign specific actions to each ship from its target we once again used loss to order the actions of each ship with the exception that ships returning to our base or in danger had precedent. 

To actually determine direction, we labeled each action with the positive amortized value if it moved towards its target, negative amortized value if it moved away, and ( 0 + value of mining ) for staying still. Then we added a collision weighting onto the values and chose the direction with the highest value.

We also ran into cases where our ships wanted to move through eachother or would get trapped. In these cases, if the ships were of the same type and neither were returning, we swapped the targets for each. 

## Collision Avoidance
To implement collision avoidance for our bot, we needed some way to anticipate what the opponent ships were doing. To do so, we stored the previous 3 moves each ship had made, and created a vector from it. This enemy vector gave us some idea of where the ship was planning on going. We purposely kept the enemy move prediction very general to not overfit it to different playstyles. We weren't confident we could do a more involved prediction analysis without accounting for the enemy strategy. We combined the vector with an uncertainty discount blur to give some amount of weight to every direction. 

From the enemy movement prediction, we added a collision cost to each square.

<div align="center"> $(Collision\ Coef)\ *\ (Collision\ Cost)\ *\ (Probability\ of\ Move) $ </div>
where the (Probability of Move) was the vector probability an enemy ship moved to the square in question. The cost of collision was
<div align="center"> $ (Collision\ Cost) = 500\ +\ cargo\ +\ (Amortized\ Value)\ -\ (Expected\ Amoritzed\ Value\ of\ New\ Ship)$ </div>
The (Collision Coef) was the number of enemy ships with less cargo from that player surrounding our ship. The idea behind it being players with more ships surrounding our ship were more of a threat given that they can better coordinate their ships to attack more effectively. 

## Returning To Base
Our returning to base strategy was coded as an independent thought from each ship's other options. Our attacking ships simply returned if they had any cargo. It is important to note, an attacking ship with cargo could also transition to a mining ship if it was better to mine than return. Our mining ships only returned if at least one of the following requirements were met: the ship was in danger, the ship was too heavy, the game was about to end, or the ship's cargo would speed up the number of turns it would take to create another ship.

We crudely assed danger on a per ship basis through each ship's distance to lighter enemy ships over the past few turns. Every lighter enemy ship 1 manhattan distance away added 2 "danger" and every lighter empty ship 2 manhattan distance away added 1 "danger." A ship was considered in danger if the sum of the "danger" over the past 3 turns exceeded 5.

A ship was considered heavy based on a global danger variable. Our global danger value started near zero and every time any ship was in danger, the global value increased. The more global danger there was, the more incentivized our ships would be to return. The implementaion of this consisted of giving the nearest dropoff from a ship the value of $\frac{(Global\ Danger\ Value)\ *\ Cargo}{dist}$. If this value was greater than the amortized value of mining, the ship would return.

We defined the endgame for each ship to be step $400 - dist - (buffer)$ where buffer was some additional time for ships to return to base. Any ship with cargo past their endgame step would be forced to return.

Lastly, in the beginning of the game we wanted ships to return more frequently to fund the creation of new ships. The return value for these ships was $\frac{(New\ Ship\ Value) * cargo/500}{dist}$ 
$\textbf{Left out our gamma garbage}$

## Dropoff Spawning
Our decision of where to spawn dropoffs was one of the most difficult problems we needed to solve. Unlike other sections, we weren't able to quantitatively figure out what truly made a dropoff position better than another besides its proximity to good halite sections. On a high level, a well positioned dropoff not only acted as a hub for ships to be created from and return to, but it was also a leading factor in board control. Often in our games, other team's dropoff positioning directly led to their domination of the board and prevented ours.

Our dropoff algorithm also focused on providing a hub for mining and not necessarily attacking ships. Due to this, our attacking ships would frequently kill an enemy ship and then proceed to not be able to successfully return to our dropoff before also getting picked off and destroyed.

To determine where we put our dropoffs, we looked at every square that met a list of requirements and choose the best one. A potential dropoff square needed to be within a certain distance from at least 2 of our friendly ships and 1 friendly dropoff, at least a certain distance away from any friendly/enemy dropoff, and not next to a 0 cost enemy ship. These conditions existed just so that we could reasonably protect the new shipyard if needed.

Of these potential locations, we summed up the top D amortized values of mining spots near the potential location. That is, if we created D new mining ships, what would the sum of their amortized values be right now. The square with the largest sum amortized value was the spot we chose. 

Once that square was chosen, we determined whether or not we should actually build that dropoff in the future. To do so, we just calculated every ship's current total savings from the introduction of the new shipyard. Each ship theoretically could save its amortized value * how many fewer turns it needs to take to now return.
<div align="center"> $ Savings = \sum_{s \in ships} \ (Amortized\ Value)_s\ *\ max(\ 0,\ dist_s - new\_dist_s\ )$ </div>

If the new dropoffs savings exceeded 500, we saved that location as a future dropoff. The first ship in the future to return to it would then create that specific shipyard.

 
    
## Ship Spawning
We originally created a model to determine the expected returns of a mining ship over time. That is, if we created a ship on turn $t$, how much halite would we expect it to mine and successfully return with. Unfortunately, with the advent of attacking ships and the varying farming strategies of opponents, this metric was often incorrect. 

We were unable to mathematically model the value of a ship over time because of that. Instead, we chose to always spawn ships up to a somewhat arbitrarily determined turn if we could. 
    

### Shipyard Protection
In watching our games, we found a large discrepancy in our games if an enemy destroyed our shipyards early in the game or not. Losing a shipyard was a huge blow; however, spending a ship to stay on the shipyard and continuously protect it was also a large cost. Replacing a shipyard cost 1000 halite (convert a ship + replace the ship) while protecting cost 500 per ship. If an enemy trades one of their ships for one of our protecting ships, than it still not only cost us 1000 halite to protect the shipyard (500 for the first ship + 500 for the second protecting ship), but it also cost us the oppertunity cost of having the ship go out and mine/attack!

To us, this originally meant defending a shipyard was only worth it if someone would attack us without protection, but wouldn't with protection.

In our imperical findings though, a shipyard ended up being worth more than 1000 halite. It provided an unquantified amount of board control for our ships. Because of this, we once again didn't come up with a completely sound solution. We chose to have a protector for every shipyard once we had reached a certain number of ships with the idea being that the decreasing marginal value of each ship would at some point be below that of spending a ship to defend our base. We chose that number to be 15 through trial and error.

We did implement a slightly more involved protection where we would leave a protector on a shipyard if there was an enemy ship nearby and we were within a manhattan distance of 1 from the shipyard. We didn't want to mess with out amortized value system too much.
